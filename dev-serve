#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'json'
require 'fileutils'
require 'optparse'

class DevServe
  CONFIG_FILENAME = '.dev-serve.yml'
  GLOBAL_CONFIG_PATH = File.expand_path("~/.config/dev-serve/config.yml")

  def initialize
    @current_dir = Dir.pwd
    @options = {}
    @project_name = nil
  end

  def run(args)
    parse_options(args)
    
    if @options[:init]
      init_config
      return
    end

    config = load_config
    command = determine_command(config)

    if command.nil?
      puts "‚ùå Could not determine development server command"
      puts "Run 'dev-serve --init' to create a config file"
      exit 1
    end

    # Determine if pre-command should run
    should_run_pre_command = false
    
    # Check if --skip-pre-command flag is set (highest priority - overrides everything)
    unless @options[:skip_pre_command]
      # Check if --run-pre-command flag is set
      if @options[:run_pre_command]
        should_run_pre_command = true
      # Check if always_run_pre_command option is enabled in config
      elsif config && config['options'] && config['options']['always_run_pre_command'] == true
        should_run_pre_command = true
      end
    end

    # Run pre-command if needed
    if should_run_pre_command
      if config && config['pre-command']
        pre_command = config['pre-command']
        puts "üîß Running pre-command..."
        puts "‚ö° Pre-command: #{pre_command}"
        puts "\n#{'-' * 50}\n"
        
        # Run the pre-command and check exit status
        success = system(pre_command)
        unless success
          puts "\n‚ùå Pre-command failed with exit code #{$?.exitstatus}"
          exit $?.exitstatus
        end
        
        puts "\n‚úÖ Pre-command completed successfully"
        puts "\n#{'-' * 50}\n\n"
      else
        if @options[:run_pre_command]
          puts "‚ö†Ô∏è  --run-pre-command flag specified but no 'pre-command' configured"
          puts "Add a 'pre-command' key to your project config to use this feature"
          puts "\n#{'-' * 50}\n\n"
        elsif config && config['options'] && config['options']['always_run_pre_command'] == true
          puts "‚ö†Ô∏è  'always_run_pre_command' is enabled but no 'pre-command' configured"
          puts "Add a 'pre-command' key to your project config to use this feature"
          puts "\n#{'-' * 50}\n\n"
        end
      end
    end

    puts "üöÄ Starting development server..."
    if @project_name
      puts "üì¶ Project: #{@project_name}"
    end
    puts "üìÅ Directory: #{@current_dir}"
    puts "‚ö° Command: #{command}"
    puts "\n#{'-' * 50}\n\n"

    exec(command)
  end

  private

  def parse_options(args)
    OptionParser.new do |opts|
      opts.banner = "Usage: dev-serve [project-name] [options]"

      opts.on("--init", "Initialize config file in current directory") do
        @options[:init] = true
      end

      opts.on("--run-pre-command", "Run the 'pre-command' (if configured) before starting the server") do
        @options[:run_pre_command] = true
      end

      opts.on("--skip-pre-command", "Skip running the 'pre-command' even if 'always_run_pre_command' is enabled") do
        @options[:skip_pre_command] = true
      end

      opts.on("-h", "--help", "Show this help message") do
        puts opts
        puts "\nExamples:"
        puts "  dev-serve                    # Run server in current directory"
        puts "  dev-serve my-app-backend     # Run server for named project"
        puts "  dev-serve --init             # Initialize config file"
        puts "  dev-serve fluid --run-pre-command # Run 'pre-command' then start server"
        puts "  dev-serve my-app --skip-pre-command # Skip pre-command even if always_run_pre_command is true"
        exit
      end
    end.parse!(args)
    
    # Check if first argument is a project name (not an option)
    if args.any? && !args.first.start_with?('-')
      @project_name = args.first
    end
  end

  def init_config
    config_path = File.join(@current_dir, CONFIG_FILENAME)
    
    if File.exist?(config_path)
      puts "‚ö†Ô∏è  Config file already exists: #{config_path}"
      return
    end

    project_type = detect_project_type
    template = generate_config_template(project_type)

    File.write(config_path, template)
    puts "‚úÖ Created config file: #{config_path}"
    puts "\nüìù Edit the file to customize your development server settings"
  end

  def generate_config_template(project_type)
    case project_type
    when :rails
      <<~YAML
        # Local Serve Configuration
        command: "bin/rails server"
        # Optional: Add environment variables
        # env:
        #   RAILS_ENV: development
        #   DATABASE_URL: postgres://localhost/myapp_dev
        # Optional: Run pre-command automatically
        # options:
        #   always_run_pre_command: true
        # Optional: Run command before starting server
        # pre-command: "git pull origin main"
      YAML
    when :node
      <<~YAML
        # Local Serve Configuration
        command: "npm run dev"
        # Optional: Specify alternative commands
        # command: "yarn dev"
        # command: "pnpm dev"
        # Optional: Run pre-command automatically
        # options:
        #   always_run_pre_command: true
        # Optional: Run command before starting server
        # pre-command: "git pull origin main"
      YAML
    when :nextjs
      <<~YAML
        # Local Serve Configuration
        command: "npm run dev"
        # Optional: Next.js specific options
        # command: "npm run dev -- --turbo"
        # Optional: Run pre-command automatically
        # options:
        #   always_run_pre_command: true
        # Optional: Run command before starting server
        # pre-command: "git pull origin main"
      YAML
    else
      <<~YAML
        # Local Serve Configuration
        # Specify your development server command
        command: "make dev"
        # Optional: Environment variables
        # env:
        #   NODE_ENV: development
        # Optional: Run pre-command automatically
        # options:
        #   always_run_pre_command: true
        # Optional: Run command before starting server
        # pre-command: "git pull origin main"
      YAML
    end
  end

  def load_config
    # If project name is provided, look it up in global config
    if @project_name
      return find_project_by_name(@project_name)
    end

    # Check for local config first
    local_config_path = File.join(@current_dir, CONFIG_FILENAME)
    if File.exist?(local_config_path)
      return YAML.load_file(local_config_path)
    end

    # Check for global config with directory mappings
    if File.exist?(GLOBAL_CONFIG_PATH)
      global_config = YAML.load_file(GLOBAL_CONFIG_PATH)
      if global_config && global_config['projects']
        current_path = File.expand_path(@current_dir)
        
        # Sort projects by path length (longest first) to match most specific path
        sorted_projects = global_config['projects'].sort_by { |p| -p['path'].length }
        
        sorted_projects.each do |project|
          project_path = File.expand_path(project['path'])
          
          # Exact match or current dir is within project path
          if current_path == project_path || current_path.start_with?("#{project_path}/")
            return project
          end
        end
      end
    end

    nil
  end

  def find_project_by_name(project_name)
    return nil unless File.exist?(GLOBAL_CONFIG_PATH)

    global_config = YAML.load_file(GLOBAL_CONFIG_PATH)
    return nil unless global_config && global_config['projects']

    # Find project by name
    project = global_config['projects'].find { |p| p['name'] == project_name }
    
    if project
      # Change to the project directory
      project_path = File.expand_path(project['path'])
      unless Dir.exist?(project_path)
        puts "‚ùå Project directory not found: #{project_path}"
        puts "Please check your global config at #{GLOBAL_CONFIG_PATH}"
        exit 1
      end
      
      # Update current directory to the project directory
      @current_dir = project_path
      Dir.chdir(project_path)
      
      return project
    else
      puts "‚ùå Project '#{project_name}' not found in global config"
      puts "Available projects:"
      global_config['projects'].each do |p|
        puts "  - #{p['name'] || 'unnamed'} (#{p['path']})"
      end
      puts "\nCheck your global config at #{GLOBAL_CONFIG_PATH}"
      exit 1
    end
  end

  def determine_command(config)
    # Priority 1: Explicit config
    return build_command(config) if config && config['command']

    # Priority 2: Auto-detect
    detect_and_run
  end

  def build_command(config)
    cmd = config['command']
    
    # Add environment variables if specified
    if config['env']
      env_vars = config['env'].map { |k, v| "#{k}=#{v}" }.join(' ')
      cmd = "#{env_vars} #{cmd}"
    end

    cmd
  end

  def detect_and_run
    project_type = detect_project_type

    case project_type
    when :rails
      "bin/rails server"
    when :nextjs
      detect_node_dev_command || "npm run dev"
    when :node
      detect_node_dev_command || "npm run dev"
    else
      nil
    end
  end

  def detect_project_type
    return :rails if File.exist?('Gemfile') && File.exist?('config/application.rb')
    return :nextjs if File.exist?('next.config.js') || File.exist?('next.config.mjs')
    return :node if File.exist?('package.json')
    
    :unknown
  end

  def detect_node_dev_command
    return nil unless File.exist?('package.json')

    begin
      package_json = JSON.parse(File.read('package.json'))
      scripts = package_json['scripts'] || {}

      # Common dev script names
      return "npm run dev" if scripts['dev']
      return "npm run start:dev" if scripts['start:dev']
      return "npm run develop" if scripts['develop']
      return "npm start" if scripts['start']
    rescue JSON::ParserError
      nil
    end

    nil
  end
end

# Run the CLI
if __FILE__ == $0
  DevServe.new.run(ARGV)
end
